pub fn ownership_test(){

//러스트는 컴파일시에 변수가 예측 가능해야된다.==>즉 메타데이터의 크기를 알수있어야된다.(원시타입은 그냥 그자체로 알수잇다.)
/*  러스트의 힙메모리 관리 규칙.
생성: 힙 메모리를 사용하기로된 데이터 타입이 선언될 때, 해당 변수 정보는 스택에 저장하고-->즉 메타 데이터가 예측이 가능해야됨.
, 실제 데이터는 힙에 저장한다.
변경: 해당 변수에 대해 데이터 크기 변경이 일어날 때, 메모리 크기를 확대/축소한다.
해제: 힙 메모리를 가리키는 변수가 해당 생존 스코프를 벗어나게 되면, 해당 힙 메모리를 해제한다.*/




    //러스트는 c와 자바의 메모리 관리와는 매우 다른 특징을 보여준다.
    //애는 힙 메모리에 대해서 소유권이라는 개념으로 다룬다.
    //힙 메모리에 있는 애들은 이 값을 담는 변수들은 stack 메모리에 두되 변수의 이름,힙메모리로의 ptr,길이만을 가지고있다.
    //만약 해당 함수의 스코프가 종료되면 힙메모리에 적재된값도 사라지는셈.

    //여기서 소유권이라는 개념은 해당 값에대해서 접근할수있는 변수를 의미한다.
    //즉 2개의 변수가 1개의 메모리 공간을 동시에 소유 할순없다.

    let a = vec![1,2,3,4];
    println!("a={:?}",a); //a=[1, 2, 3, 4]

    let b = a;
    println!("b={:?}",b); //b=[1, 2, 3, 4]
    println!("a={:?}",a); //에러-->즉 b가 원래 a가 가리키던 메모리 공간을 "소유"하게된것이고 a는 이제 그 무엇도
    //소유 하지않음-->즉 출력시 에러가 발생한다.

}

//혹은 아래 같이 함수에 변수를 넘길경우에도 소유권이 넘어간다.
fn main(){
    let s = String::from("Hello Jeff");
    let point = cal_point(s);  //소유권 이동 발생

    println!("s = {:?}", s);  //에러 발생
    println!("point = {}", point);  // point = 70
}

fn cal_point(w:String) -> i32 {
    let point = w.to_uppercase().bytes()
        .filter(|c| (*c >= b'A' && *c <= b'Z'))
        .map(|c| (c-b'A') as i32)
        .sum();
    return point;
}

fn main(){
    let a = 1;
    sub_fn();
    //b는 sub_fn이라는 스코프 안에서만 유효한 변수이다. 즉 스코프 종료와 동시에 사라지는값.
    assert_eq!(10,b); //error
    assert_eq!(1,a); //ok
}

fn sub_fn(){
    let b = 10;
    assert_eq!(10,b); //ok

    {
        assert_eq!(10,b); //ok

        let c = vec![1,2,3];
        assert_eq!(vec![1,2,3],c); //ok
    }
    assert_eq!(vec![1,2,3],c); //error
    assert_eq!(10,b); //ok 
}

//위의 예제에서 함수의 변수로 넘겨주면 소유권이 사라져서 기존 변수가 쓸수없는 상황이된다.
//이는 자바나 c와는 사뭇 다른대 이런 상황을 방지 하기위해서 소유한 메모리에대한 "대여"가 가능하다.
fn main(){
    let a = vec![1,2,3];
    println!("a={:?}",a); //a=[1, 2, 3]

    let cnt = get_even_cnt(&a);///-->즉 &기호는 참조값을 넘긴다는 의미이기도 하나 또한 borrow의 의미이기도하다.
    println!("enve count = {}", cnt);  //even count = 1
    println!("a={:?}",a);  //a=[1, 2, 3]-->변수의 소유권은 그대로이다.
}

fn get_even_cnt(x:&Vec<i32>) -> i32{
    let mut cnt = 0;
    for i in x {// borrow해온 값에대해서는 vec이든 map이든 내부의 값들은 전부 참조값으로 온다.
        //특히 map의 경우 빌려온 경우라면 get메서드로 꺼내도 참조값이 나온다.
        if *i % 2 == 0 {cnt += 1;}
    }
    x.iter().filter(|&&i| i%2==0).count();//--> 같은 표현.
    return cnt;
}

//아래는 쓰기 대여권을 부여하는 과정이다. 이때 쓰기 소유권이 부여된애만 read와 write가 가능하며 
//한 메모리 공간에 대한 쓰기 대여권은 1명만 존재해야됨. 즉 쓰기 대여권이 부여된 상황에서는 원본도 read,write
//가 불가능하며 당연하게도 쓰기 대여권을 발행하는 변수는 mut가 있어야한다.
//즉 쓰기 대여권은 말하자면 소유권의 임시 이동이라고 생각해된다.
//쓰기 대여권이 부여된 순간부터는 쓰기 대여권이끝나기전까지 원본,읽기 대여권이 부여된 애들은 그냥 아무것도 못한다고 보면된다.
fn main(){
    let mut a = vec![1,2,3];
    println!("a={:?}",a);

    add_one(&mut a);  // 쓰기가능한 대여권 부여
    println!("a={:?}",a);  //2,3,4
}

fn add_one(x:&mut Vec<i32>) {
    x.iter_mut().for_each(|i| *i += 1);
}

//그러면 대여권은 언제끝나는가?--> rust는 알아서 코드내부에서 대여권이 부여된 변수가 더이상 쓰이지 않는시점에서
//대여권을 끝낸다.

fn main(){
    //1. 소유권 변수 x
    let mut x = vec![1,2,3];    
    println!("x={:?}",x);

    //2. 읽기 대여
    let rx = &x;
    println!("rx={:?}",rx);

    //3. 쓰기 대여
    let wx = &mut x;    
    wx[0] = 4;
    println!("wx={:?}",wx);

    //4. 원래의 소유권 변수 x
    println!("x={:?}",x);    
    //println!("wx={:?}",wx);
}

//위의 코드처럼 읽기대여 rx는 println을 하고나서 더이상 선언이 안되므로 해당줄 이하로는 더이상 쓸수가없다이말.
//또한 4번케이스에서 아래에 주석 처리된 println을 해제하면 원본을 프린트하는 과정도 에러가발생한다.
//왜냐면 wx를 한번더쓰고있다-->쓰기 대여권이 살아있기떄문이다.

fn main(){
    //1. 소유권 변수 x
    let mut x = vec![1,2,3];     
    println!("x={:?}",x);    

    //2. 읽기 대여
    let rx = &x;

    x[0] = 4;  //에러: '읽기 대여' 도중에 쓰기 수행

    println!("rx={:?}",rx);
}
//또한 읽기 대여권이 살이있는동안 같은 메모리에 대한 쓰기는 불가하다.

fn main(){
    let x:&String;

    {
        let s = String::from("Jeff");
        x = &s;
    }

    println!("x={}",x);    
}
//해당 코드는 심각한 에러를 보여주는대 s라는 변수는 중간의 {}블럭에서만 유효한변수.
//그런대 {}가 끝나면 s는 사라지고 x는 없어진 s의 공간을 즉 없는메모리공간을 지목하게되므로 에러발생.
//러스트는 힙이든 스택메모리든 변수의 생존주기는 해당 스코프가 살아있는 동안만 가능하다는걸 기억하자.



//소유권 대여의 문제는 결국 copy trait이 따로 구현이 안된 것들에 해당되며-->대부분의 힙메모리 이용 및 구조체도 이에 해당됨.
//보통의 i32,f32같은 원시형데이터들은 copy trait이 구현된것들에 해당 즉 소유권 문제로부터 자유로움.