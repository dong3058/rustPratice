pub fn smartpointer_test(){

}

//러스트에서 힙메모리에 저장된 데이터를 담는 변수는 실제 스택 메모리에 해당 데이터에대한 메타데이터를 담은
//스마트 포인터란게 저장된다. 즉 변수는 해당 스마트 포인터를 담고있다는것.
//여기서 역참조 실제 데이터 즉 힙메모리에 담긴 데이터를 꺼낼려면 이 스마트 포인터로부터 실제 데이터를 가져오는 과정이 필요하다.
//이과정을 deref trait으로 구현한것이 string,vec,box등에 해당된다.
//즉 변수에 저장된 데이터가 단순 메모리 주소가 아니라 스마트 포인터 라는 구조체 데이터인지라
//*연산만 한다고 원본 데이터가 나오지 못하는대 *를 스마트 포인터에 했을때 원본 데이터가 나오도록 도와주는 trait이 바로 deref에 해당된다.
// let b=&a를 하면 a의 스마트 포인터 로부터 주소를 가져오고 *b로부터 실제데이터를 가져온다.
//deref가 구현된 스마트 포인터에 *를 붙일 경우 실제로는 *Deref::deref(&x)이 형식으로 작용한다.
//예를 들어서 String의 경우 deref 결과가 &str이므로 최종결과는 str
// vec의 경우에는 *(&[T])==> [T]
// BOX 의 경우 *(&T)==>T 가나온다.

fn main() {
    let s = String::from("hello");
    let ss = *s;
    println!("{}", s);
} 
//이코드는 ss=*s에서 에러가 발생하는대 ss=str이런꼴로 저장되고
//이 str은 static 메모리에 존재한다. 즉 변수형태로 소유권을 양도할수있는 heap의 밖이기에 주소값을 넘겨주는
//&str로 쓰여야 되기때문.


//암묵적 역참조는 함수,메서드의 파라미터로 넘겨지거나 혹은 파라미터로넘겨질때 타입이 안맞는 경우 발생하는 강제적 역참조이다.
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main(){
     let s = String::from("Tom");
    hello(s);  //기대한 데이터 타입은 &str인대 string이 왓으므로 에러가 발생==>즉 타입이 다르므로 에러가발생
    hello(*s);//이거는 s의 역참조 즉 str이 넘어오므로 에러가 발생-->타입이 다름
    hello(&s);//이거는 변수도 &s로 부텅서 넘어가는대 s의 타입이 str이 아니므로 강제적 역참조가 발생한다. 즉 &str이 되고 이게 타입과 일치하므로 패스.
}
 

 fn print_array(arr:&[i32]) {
    println!("{:?}", arr);
}

fn main(){
    let v = vec![1,2,3];
    print_array(&v); // 데이터 타입은 &[i32]를 기대하는대 실제로 넘어온건 &v 즉 vec의 참조꼴이다.
    //고로 역참조가 발생하는대 vec의 역참조는 즉 *(&[T])==> [T] 이므로 요구되는 데이터 타입과 일치 해서 패스한다.
}   //[T]라는 데이터는 컴파일 단계에서 그 크기를 가늠할수없는 데이터이다.
//러스트는 컴파일 단계에서 그 크기를 예측할수잇는 데이터만 있어야된다.
//예를들어서 vec의 경우 heap에 저장되는 데이터 크기는 유동적이나 stack메모리에 저장된 smart potiner 구조체는
//그 크기가 정해져있다.-->들어가는 메타 데이터가 한정되므로.
//그러나 [T]은 그냥 순수 데이터 그 자체다.즉 T타입의 데이터들의 집합체에 해당된다.
//이 T타입 데이터 집합체는 vec,map등 여러개가 존재한다.
// 즉 컴파일 시점에서 애가 T타입의 집합체인건 알겠는대 그게 뭔지를 모른다=-->메타데이터를 작성할수 없다 이말이된다.
//이는 str에도 해당되는대 우리는 str에 얼마만큼의 문자열이 들어갈지 컴파일 단계에서는 알수가없다.
//그에 반해 &str은 주소값즉 byte데이터로 그 크기가 정해져있고 string은 smart pointer로 메타 데이터를 형성하므로
//사용이 가능하다 이말이다.